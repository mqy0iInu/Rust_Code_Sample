// ============================================================================================================
// [ChatGPTで生成したコード]
// ============================================================================================================
// このコードでは、MutexとArcを使用して共有データを保護する。
// Mutexは、複数のスレッドが同時にデータにアクセスするのを防ぐために使用される。
// Arcは、共有所有権を可能にするために使用される。

// まず、共有データを格納するためにMutexとArcを作成する。
// それから、cloneメソッドを使用して各スレッドに共有データの所有権を渡す。
// スレッド1とスレッド2のそれぞれで、共有データをロックしてからデータを操作する。
// ロックされたデータは、MutexGuardと呼ばれるスマートポインタの形式で取得され
// 操作が完了したら自動的に解放される。
// 最後に、スレッド1とスレッド2の終了を待ち、最終的なデータを取得して表示する。

// 注意点として、Mutexはデータ競合を回避するためのものであるが、
// 適切なロック/ロック解除のパターンを確保しないと
// デッドロックが発生する可能性があることに注意してください。
// ============================================================================================================

use std::sync::{Arc, Mutex};
use std::thread;

fn main()
{
    // 共有データを格納するためのMutexとArcを作成
    let shared_data = Arc::new(Mutex::new(0));

    // スレッド1で共有データを操作する
    let data1 = shared_data.clone();
    let thread1 = thread::spawn(move || {
        // Mutexをロックしてデータを操作
        let mut data = data1.lock().unwrap();
        *data += 1;
        println!("スレッド1: データを操作しました: {}", *data);
    });

    // スレッド2で共有データを操作する
    let data2 = shared_data.clone();
    let thread2 = thread::spawn(move || {
        // Mutexをロックしてデータを操作
        let mut data = data2.lock().unwrap();
        *data += 2;
        println!("スレッド2: データを操作しました: {}", *data);
    });

    // スレッド1とスレッド2の終了を待つ
    thread1.join().unwrap();
    thread2.join().unwrap();

    // 共有データの最終値を取得
    let final_data = shared_data.lock().unwrap();
    println!("最終データ: {}", *final_data);
}
